"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const abiParser_1 = require("./abiParser");
const utils_1 = require("./utils");
function generateSource(abi, context) {
    const parsedContractAbi = abiParser_1.parse(abi);
    return codeGenForContract(abi, parsedContractAbi, context);
}
exports.generateSource = generateSource;
// @todo better typings for web3
function codeGenForContract(abi, input, context) {
    const typeName = `${context.fileName}`;
    return `/* GENERATED BY TYPECHAIN VER. ${utils_1.getVersion()} */
/* tslint:disable */
  
import { BigNumber } from "bignumber.js";
import { TypeChainContract, promisify, ITxParams, IPayableTxParams, DeferredTransactionWrapper } from '${context.relativeRuntimePath}'

export class ${typeName} extends TypeChainContract {
    public readonly rawWeb3Contract: any;
  
    public constructor(web3: any, address: string | BigNumber) {
      const abi = ${JSON.stringify(abi)};
      super(web3, address, abi);
    }

    static async createAndValidate(web3: any, address: string | BigNumber): Promise<${typeName}> {
      const contract = new ${typeName}(web3, address);
      const code = await promisify(web3.eth.getCode, [address]);
      if (code === "0x0") {
        throw new Error(\`Contract at \${address} doesn't exist!\`);
      }
      return contract; 
    }
    
    ${input.constants
        .map(constant => `public get ${constant.name}(): Promise<${constant.output.generateCodeForOutput()}> { return promisify(this.rawWeb3Contract.${constant.name}, []); }`)
        .join("\n")} 
      ${input.constantFunctions
        .map(constantFunction => `public ${constantFunction.name}(${constantFunction.inputs
        .map(codeGenForParams)
        .join(", ")}): Promise<${codeGenForOutputTypeList(constantFunction.outputs)}> { return promisify(this.rawWeb3Contract.${constantFunction.name}, [${constantFunction.inputs.map(codeGenForArgs).join(", ")}]); }`)
        .join(";\n")} 

        ${input.functions
        .map(func => {
        const txParamsType = func.payable ? "IPayableTxParams" : "ITxParams";
        return `public ${func.name}Tx(${func.inputs
            .map(codeGenForParams)
            .join(", ")}): DeferredTransactionWrapper<${txParamsType}> { return new DeferredTransactionWrapper<${txParamsType}>(this, "${func.name}", [${func.inputs.map(codeGenForArgs).join(", ")}]);
                }`;
    })
        .join(";\n")} 
}`;
}
function codeGenForParams(param) {
    return `${param.name || "index"}: ${param.type.generateCodeForInput()}`;
}
function codeGenForArgs(param) {
    return `(${param.name || "index"}).toString()`;
}
function codeGenForOutputTypeList(output) {
    if (output.length === 1) {
        return output[0].generateCodeForOutput();
    }
    else {
        return `[${output.map(x => x.generateCodeForOutput()).join(", ")}]`;
    }
}
